# gaussian_input_ui.py

def gaussian_input_ui():
    import streamlit as st
    import base64
    import requests
    import os
    from rdkit import Chem
    from rdkit.Chem import AllChem
    import PyPDF2

    def smiles_to_xyz(smiles, optimize=True):
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None
        mol = Chem.AddHs(mol)
        AllChem.EmbedMolecule(mol)
        if optimize:
            AllChem.UFFOptimizeMolecule(mol)
        conf = mol.GetConformer()
        xyz = ""
        for atom in mol.GetAtoms():
            pos = conf.GetAtomPosition(atom.GetIdx())
            xyz += f"{atom.GetSymbol()} {pos.x:.4f} {pos.y:.4f} {pos.z:.4f}\n"
        return xyz.strip()

    def extract_pdf_text(uploaded_file):
        try:
            reader = PyPDF2.PdfReader(uploaded_file)
            text = ""
            for page in reader.pages:
                text += page.extract_text() + "\n"
            return text.strip()
        except:
            return None

    st.header("üß™ Gaussian Input File Generator")

    tabs = st.tabs(["üìã Form-based", "üí¨ Prompt-based (AI helps route)", "üìÑ Extract from Paper"])

    with tabs[0]:
        st.subheader("üìã Form-based Generator")
        smiles = st.text_input("Enter SMILES string:")
        apply_opt = st.checkbox("Apply basic geometry optimization (UFF)", value=True)
        method = st.selectbox("Select method", ["B3LYP", "HF", "M06-2X", "PBE0"])
        basis = st.selectbox("Select basis set", ["6-31G(d)", "6-311++G(d,p)", "cc-pVDZ", "LANL2DZ"])
        job_type = st.selectbox("Job type", ["Opt", "Freq", "SP", "Opt Freq"])
        charge = st.number_input("Charge", value=0, step=1)
        multiplicity = st.number_input("Multiplicity", value=1, step=1)
        custom_route = st.text_input("Optional: Extra route keywords")

        if st.button("Generate .gjf file from SMILES"):
            coords = smiles_to_xyz(smiles, optimize=apply_opt)
            if coords is None:
                st.error("Invalid SMILES string. Please check and try again.")
            else:
                route_line = f"#{method}/{basis} {job_type} {custom_route}".strip()
                gjf_content = f"""%chk=calc.chk
%mem=4GB
%nprocshared=4
{route_line}

Generated by ChemAssist

{charge} {multiplicity}
{coords}

"""
                st.code(gjf_content, language="gjf")
                b64 = base64.b64encode(gjf_content.encode()).decode()
                href = f'<a href="data:file/gjf;base64,{b64}" download="generated_input.gjf">‚¨áÔ∏è Download .gjf file</a>'
                st.markdown(href, unsafe_allow_html=True)

    with tabs[1]:
        st.subheader("üí¨ Prompt-based Route Helper")
        smiles = st.text_input("SMILES for molecule:", key="prompt_smiles")
        prompt = st.text_area("Describe what kind of calculation you want:",
                              placeholder="e.g. Optimization and frequency calculation using B3LYP and 6-31G(d)")
        apply_opt2 = st.checkbox("Apply basic geometry optimization (UFF)", value=True, key="opt2")

        if st.button("Generate input using AI + form") and smiles.strip() and prompt.strip():
            coords = smiles_to_xyz(smiles, optimize=apply_opt2)
            if coords is None:
                st.error("Invalid SMILES string. Please check and try again.")
            else:
                try:
                    headers = {
                        "Authorization": f"Bearer {os.getenv('GROQ_API_KEY')}",
                        "Content-Type": "application/json"
                    }
                    data = {
                        "model": "llama3-70b-8192",
                        "messages": [
                            {"role": "system", "content": "You are a Gaussian input route section generator. Only return the proper route line with method, basis set, and job type. Do NOT generate molecular coordinates or full .gjf content."},
                            {"role": "user", "content": prompt}
                        ]
                    }
                    response = requests.post("https://api.groq.com/openai/v1/chat/completions", headers=headers, json=data)
                    response.raise_for_status()
                    route_line = response.json()['choices'][0]['message']['content'].strip()

                    gjf_content = f"""%chk=calc.chk
%mem=4GB
%nprocshared=4
{route_line}

Generated by ChemAssist + Groq AI

0 1
{coords}

"""
                    st.code(gjf_content, language="gjf")
                    b64 = base64.b64encode(gjf_content.encode()).decode()
                    href = f'<a href="data:file/gjf;base64,{b64}" download="ai_generated_input.gjf">‚¨áÔ∏è Download .gjf file</a>'
                    st.markdown(href, unsafe_allow_html=True)

                except Exception as e:
                    st.error(f"üî• API error or model issue: {e}")

    with tabs[2]:
        st.subheader("üìÑ Extract Calculation Method from Research Paper")
        uploaded_paper = st.file_uploader("Upload a research paper (PDF)", type=["pdf"])

        if uploaded_paper is not None:
            text = extract_pdf_text(uploaded_paper)
            if not text:
                st.error("Could not extract text from the uploaded PDF.")
            else:
                try:
                    headers = {
                        "Authorization": f"Bearer {os.getenv('GROQ_API_KEY')}",
                        "Content-Type": "application/json"
                    }
                    data = {
                        "model": "llama3-70b-8192",
                        "messages": [
                            {"role": "system", "content": "You are a scientific assistant. If the paper contains a Gaussian calculation method, extract it precisely. If the paper is unrelated to molecular calculations, reply with: 'This document does not appear to contain Gaussian-related molecular calculations.'"},
                            {"role": "user", "content": text[:10000]}  # limit to first 10k chars
                        ]
                    }
                    response = requests.post("https://api.groq.com/openai/v1/chat/completions", headers=headers, json=data)
                    response.raise_for_status()
                    result = response.json()['choices'][0]['message']['content']
                    st.markdown("**Extracted Method Section:**")
                    st.info(result)
                except Exception as e:
                    st.error(f"Error analyzing paper: {e}")
